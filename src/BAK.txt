fn writeloop(mut writer: PpmWriter) {
    // Camera
    let width = writer.x_size;
    let height = writer.y_size;
    let viewport_height = 2.0;
    let viewport_width = (width / height) as f64 * viewport_height;
    let focal_length = 2.0;
    let origin = &Vector3::right() * 1.0; // TODO: have to shift origin to right to get sphere on screen... why?
    let horizontal = Vector3 {
        x: viewport_width,
        y: 0.0,
        z: 0.0,
    };
    let vertical = Vector3 {
        x: 0.0,
        y: viewport_height,
        z: 0.0,
    };
    let lens = Vector3 {
        x: 0.0,
        y: 0.0,
        z: focal_length,
    };
    let lower_left_corner = origin - (horizontal / 2.0) - (vertical / 2.0) - lens;
    for j in (0..(writer.y_size)).rev() {
        for i in (0..(writer.x_size)).rev() {
            let u = i as f64 / (writer.x_size - 1) as f64;
            let v = j as f64 / (writer.y_size - 1) as f64;
            let r = Ray {
                origin: origin,
                dir: lower_left_corner + u * horizontal + v * vertical - origin,
            };
            let c = (&r); //Color { x: r, y: g, z: b };
                          // let c = Color { x: u, y: v, z: 0.5 };
            writer.write(&c).expect("Error writing vector");
        }
    }
}
pub struct PpmWriter {
    x_size: u32,
    y_size: u32,
    idx: u32,
    rowidx: u32,
    file: File,
}
impl PpmWriter {
    pub fn new(x_size: u32, y_size: u32, name: &str) -> Result<PpmWriter, std::io::Error> {
        let file = File::create(format!("{}.ppm", name))?;
        let mut out = PpmWriter {
            x_size: x_size,
            y_size: y_size,
            idx: 0,
            rowidx: 0,
            file,
        };
        match out
            .file
            .write(format!("P3 \n{} {} \n255 \n", x_size, y_size).as_bytes())
        {
            Err(e) => return Err(e),
            Ok(_) => return Ok(out),
        }
    }
    pub fn write(&mut self, color: &Color<f64>) -> Result<&str, std::io::Error> {
        if self.rowidx == self.x_size {
            self.file.write(b"\n")?;
            self.idx += self.rowidx;
            self.rowidx = 0;
            if ((self.idx) % ((self.x_size * self.y_size) / 16)) == 0 {
                println!("{}/{} lines complete", self.idx / self.y_size, self.y_size);
            };
        }
        self.file.write(
            format!(
                "{} {} {} ",
                (color.x * 255.999) as i64,
                (color.y * 255.999) as i64,
                (color.z * 255.999) as i64
            )
            .as_bytes(),
        )?;
        self.rowidx += 1;
        return Ok("Success");
    }
}
